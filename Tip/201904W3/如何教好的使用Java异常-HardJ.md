#### 如何较好的使用异常

​	异常在编写Java程序中无处不在，使用异常可以提高程序的可靠性。但如果使用不当，会造成很多负面影响。下面是几条关于异常使用的建议(来自《Effective Java》)

1. 只针对异常的情况才使用异常
   - 异常机制设计的初衷是为了用于不正常的情形，所以很少会有JVM实现试图对异常进行优化，使得与测试一样快速。
   - 把代码放在try-catch块中反而阻止了现代JVM实现本来可能要执行的某些特定优化。
   - 异常不能用于普通控制流。
   - 编写API不应该迫使客户端为了正常的控制流使用异常。
2. 对可恢复的情况使用受检异常，对于编程错误使用运行时异常
   - 如果期望调用者能够适当地恢复，对于这种情况就应该使用受检异常。
   - 用运行时异常来表明编程错误，大多数的运行时异常都表示前提违例。
   - 如果程序抛出未检查异常，往往属于不可恢复的。
   - 如果不清楚程序是否可恢复，最好使用未受检的异常。
   - 由于受检查异常往往指明了可恢复的条件，所以，对于这样的异常可以提供一些方法辅助程序恢复。

3. 避免不必要地使用受检的异常
   - 过分使用受检的异常会使API使用起来非常不方便。
   - 如果方法抛出一个或多个受检的异常，将给程序员增添了不可忽视的负担。

4. 优先使用标准的异常
   - 重用现有异常使得API更新容易学习和使用，对于用到这些API的程序来说可读性更好。
   - 对于常用异常的使用，一定要确保抛出异常的条件与该异常的文档中描述的条件一致。这种重用必须建立在语义的基础上，而不是建立在名称的基础上。
   - 常用的异常：

      - IllegalArgumentException：非null的参数值不正确
      - IllegalStateException: 对于方面调用而言，对象的状态不合适
      - NullPointerException: 在禁止使用null的情况下参数值为null
      - IndexOfBoundsException: 下标参数值越界
      - CocurrentModificationException: 在禁止并发修改的情况下，检测到对象的并发秀爱
      - UnsupportedOperationException: 对象不支持用户请求的方法


5. 抛出与抽象相对应的异常

   - 对于高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常，即异常转译。
   - 通过异常转译的形式，底层的异常（原因）被传到高层的异常，高层的异常提供访问方法来获得低层的异常。（如果低层异常对于高层异常有帮助）
   - 如果不能阻止或者处理来自更低层的异常，一般做法是异常转译，除非低层方法碰巧可以保证它所抛出异常适用于高层才可直接传播。
6. 每个方法抛出的异常都要有文档
   - 始终要单独地声明受检的异常，并且利用Javadoc的@throws标记，准确地记录下抛出每个异常的条件。
   - 永远不要声明一个方法"throws Exception",或者是"throws Throwable"。
   - 使用Javadoc的@throws标签记录系一个方法可能抛出的每个未受检异常，但是不要使用throws关键字将未受检异常包含在方法的声明中。

7. 在细节消息中包含能捕获失败的信息
   - 为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。


8. 努力使失败保持原子性
   - 失败的方法调用应该使方法保持在被调用之前的状态。具体这种属性的方法被称为具有失败原子性。
   - 作为方法规范的一部分，产生的任何异常都应该让对象保持在该方法调用之前的状态。如果违反这条规则，API文档就应该清楚地指明对象将会处于什么样的状态。

9. 不要忽略异常
   - 当catch块中为空时，应该包含一条说明，解释为什么可以忽略这个异常。

   - 正确的处理异常能够挽回失败。