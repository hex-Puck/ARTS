| 课次序号 |         第一节课          |             第二节课             |
| :------: | :-----------------------: | :------------------------------: |
|    1     | JNIEnv 模拟、JNI 数据类型 |       C 访问Java属性、方法       |
|    2     |  NDK 环境搭建与入门使用   | 访问构造方法、父类方法、中文乱码 |
|    3     |     数组的处理、引用      |  异常处理、缓存策略、预处理指令  |

> 还需要强化的部分：
>
> * jni 中各种方法的使用，以及注意事项；

# 1 预编译指令

## 1.1 include

`#include ...` 属于 C 语言中的预编译指令。C 语言的整个执行流程如下：

1. 编辑源代码；
2. 编译：形成目标代码 `.obj` 文件；
3. 链接：将目标代码与 C 函数库链接合并，形成最终的可执行二进制文件；
4. 执行：获得最终结果；

其中在编译之前，还存在『预编译』过程：为编译作准备工作，完成代码文本的替换工作。

~~~c
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

void main(int argc, char* argv) {

#include "myTxt.txt"
	
	system("pause");
}
~~~

比如此处的 `#include "myTxt.txt"` 指令就是属于预编译指令，插入了下述文件内容：

~~~c
printf("This is a included file!\n");
~~~

而头文件的作用是：告诉编译器有这样一个函数，链接器负责找到这个函数的实现。

## 1.2 define

`define`指令有以下 3 种功能：

* 定义标识以防止文件重复引入；

  比如 `jni.h` 中定义了标识 `.cpp` 语法的文件：

  ~~~c
  #ifdef __cplusplus
  /*
   * Reference types, in C++
   */
  class _jobject {};
  class _jclass : public _jobject {};
  class _jstring : public _jobject {};
  class _jarray : public _jobject {};
  class _jobjectArray : public _jarray {};
  class _jbooleanArray : public _jarray {};
  class _jbyteArray : public _jarray {};
  class _jcharArray : public _jarray {};
  class _jshortArray : public _jarray {};
  class _jintArray : public _jarray {};
  class _jlongArray : public _jarray {};
  class _jfloatArray : public _jarray {};
  class _jdoubleArray : public _jarray {};
  class _jthrowable : public _jobject {};
  
  typedef _jobject*       jobject;
  typedef _jclass*        jclass;
  typedef _jstring*       jstring;
  typedef _jarray*        jarray;
  typedef _jobjectArray*  jobjectArray;
  typedef _jbooleanArray* jbooleanArray;
  typedef _jbyteArray*    jbyteArray;
  typedef _jcharArray*    jcharArray;
  typedef _jshortArray*   jshortArray;
  typedef _jintArray*     jintArray;
  typedef _jlongArray*    jlongArray;
  typedef _jfloatArray*   jfloatArray;
  typedef _jdoubleArray*  jdoubleArray;
  typedef _jthrowable*    jthrowable;
  typedef _jobject*       jweak;
  
  
  #else /* not __cplusplus */
  
  /*
   * Reference types, in C.
   */
  typedef void*           jobject;
  typedef jobject         jclass;
  typedef jobject         jstring;
  typedef jobject         jarray;
  typedef jarray          jobjectArray;
  typedef jarray          jbooleanArray;
  typedef jarray          jbyteArray;
  typedef jarray          jcharArray;
  typedef jarray          jshortArray;
  typedef jarray          jintArray;
  typedef jarray          jlongArray;
  typedef jarray          jfloatArray;
  typedef jarray          jdoubleArray;
  typedef jobject         jthrowable;
  typedef jobject         jweak;
  
  #endif /* not __cplusplus */
  ~~~

  用于区分 `.c` 文件 和 `.cpp` 文件，以标识使用的不同语法规则。

  为了防止头文件的重复引入，可以定义头文件引入的标识：

  ~~~c
  // #pragma once
  
  #ifndef AH
  #define AH
  #include "B.h"
  
  void printfA();
  
  #endif
  ~~~

  上述是定义的 `A.h`，以及下述的 `B.h` ：

  ~~~c
  // #pragma once
  
  #ifndef BH
  #define BH
  #include "A.h"
  
  void printfB();
  
  #endif
  ~~~

  通过定义标识，防止循环地引入头文件。

* 定义常数：`#define MAX 100` 编译器中编译时，会自动做文本的替换。

* 定义宏函数：

  ~~~c
  #define _CRT_SECURE_NO_WARNINGS
  
  #include <stdio.h>
  #include <stdlib.h>
  
  #include "A.h"
  
  void printfA() {
  	printf("printf A\n");
  }
  
  void printfB() {
  	printf("printf B\n");
  }
  
  #define printf(NAME) printf##NAME()
  
  void main(int argc, char* argv) {
  // #include "myTxt.txt"
  
  	printf(A);
  	
  	system("pause");
  }
  ~~~

  用红函数的形式定义了函数别名。

# 2 JNI 开发流程

JNI（Java Native Interface）：Java 调用 C/C++，C/C++ 调用 Java 的一套 API。

> Java 代码 和  Native 代码相互访问！
>
> NDK 和 JNI 是两个不同的概念：
>
> * 如果想要简单的使用 Java 代码调用 Native 代码，可以直接使用 Eclipse 的 Java 工程；
>
>   同时使用 Visual Studio 作为编译 C/C++ 代码的工具；
>
>   在 Windows 平台下，生成的是 .dll 文件。
>
> * 如果是在 Android 工程中，则需要使用 NDK ，且在 NDK 中有使用到 JNI。
>
>   NDK 替代了 Visual Studio 作为编译工具。
>
>   在 Linux 平台下，生成的是 .so 文件。

## 2.1 Java 访问 Native

在 Eclipse 中创建 Java 工程，并在其中访问 Native 方法，步骤如下：

1. 编写 native 方法；

   ~~~java
   package com.arthur.ndk;
   
   public class JniTest {
       
       public native static String getStringFromNative();
   
       public static void main(String[] args) {
           System.out.println(getStringFromNative());
       }
   
   }
   
   ~~~

   简单地定义了一个 JniTest 类，并在其中声明了一个 native 方法。

2. javah 命令，生成 .h 头文件；

   ~~~xml
   E:\app\com.arthur.ndk\src>javah com.arthur.ndk.JniTest
   ~~~

   在源代码目录下 src 中使用 javah 指令生成 .java 文件中 native 对应的头文件，文件命名为：`com_arthur_ndk_JniTest.h`

   ~~~c
   /* DO NOT EDIT THIS FILE - it is machine generated */
   #include <jni.h>
   /* Header for class com_arthur_ndk_JniTest */
   
   #ifndef _Included_com_arthur_ndk_JniTest
   #define _Included_com_arthur_ndk_JniTest
   #ifdef __cplusplus
   extern "C" {
   #endif
   /*
    * Class:     com_arthur_ndk_JniTest
    * Method:    getStringFromNative
    * Signature: ()Ljava/lang/String;
    */
   JNIEXPORT jstring JNICALL Java_com_arthur_ndk_JniTest_getStringFromNative
     (JNIEnv *, jclass);
   
   #ifdef __cplusplus
   }
   #endif
   #endif
   
   ~~~

3. 复制 .h 头文件到 cpp 工程中；

   意味着将在 VS2015 IDE 中编写 Native 代码，实现头文件中声明的方法。

   > 其中 `#include <jni.h>` 头文件，以及相关的类型是不存在，需要在 jdk 中找出来并复制到工程中。

4. 复制 jni.h 和 jni_md.h 文件到 cpp 工程中；

5. 实现 .h 头文件中声明的函数；

   ~~~c
   #define _CRT_SECURE_NO_WARNINGS
   
   #include <stdio.h>
   #include <stdlib.h>
   #include "com_arthur_ndk_JniTest.h"
   
   /*
   * Class:     com_arthur_ndk_JniTest
   * Method:    getStringFromNative
   * Signature: ()Ljava/lang/String;
   */
   JNIEXPORT jstring JNICALL Java_com_arthur_ndk_JniTest_getStringFromNative
   (JNIEnv *jniEnv, jclass jclz) {
   	// 将 C 字符串，转化为 Java 字符串
   	return (*jniEnv)->NewStringUTF(jniEnv, "Hello NDK!");
   }
   
   void main(int argc, char* argv) {
   	printf("Hello World!\n");
   	
   
   	system("pause");
   }
   ~~~

   `NewStringUTF()` 将 C 字符串，转化为 Java 字符串。

6. 生成 .dll 文件；

   项目的**配置类型**为：动态库 .dll。

   IDE 工具的相关配置，**生成解决方案**后，生成了命名为：CProjectDemo.dll 动态库文件。

7. 配置 .dll 文件所在目录到环境变量；

   原因：在目标 Java 工程中，无法找到对应的动态库文件。

8. 重启Eclipse，并运行工程。

   ~~~java
   package com.arthur.ndk;
   
   public class JniTest {
       
       public native static String getStringFromNative();
   
       public static void main(String[] args) {
           System.out.println(getStringFromNative());
       }
       
       static{
           try{
               String content = System.getProperty("java.library.path");
               System.out.println("content:"+content);
               
               System.loadLibrary("CProjectDemo");
           }catch(Exception e){
               System.out.println(e.getMessage());
           }
       }
   
   }
   
   ~~~

在 Windows 平台下，Java 工程默认在加载 Library 时，会去找对应的 Xxx.dll 文件；对应在 Linux 平台下，加载的是 Xxx.so 文件。

> **静态库**和**动态库**的区别：
>
> - 『静态库（又称为：静态链接库）』是把程序运行时需要使用的函数编译在一个二进制文件中，扩展名为 .lib。在 Linux 下对应的是 .a 文件。在最终的可运行程序中，包含有静态库文件中的指令。
> - 『动态库（又称为：动态链接库、共享库）』仅是把 .dll 中的函数名和参数放在应用程序中，在程序运行时加载里面的内容。在 Linux 下对应的是 .so 文件。在最终的可运行程序中，不包含有动态库文件的指令。
> - 都是可以共享代码；

## 2.2 JNIEnv

在实践中，发现 C 和 C++ 代码在使用 JNIEnv 类型变量时有不同的写法。在 `jni.h` 文件有如下定义：

~~~c
struct _JNIEnv;
struct _JavaVM;
typedef const struct JNINativeInterface* C_JNIEnv;

#if defined(__cplusplus)
typedef _JNIEnv JNIEnv;
typedef _JavaVM JavaVM;
#else
typedef const struct JNINativeInterface* JNIEnv;
typedef const struct JNIInvokeInterface* JavaVM;
#endif

/*
 * Table of interface function pointers.
 */
struct JNINativeInterface {
    void*       reserved0;
    void*       reserved1;
    void*       reserved2;
    void*       reserved3;

    jint        (*GetVersion)(JNIEnv *);
    
    ...
}

/*
 * C++ object wrapper.
 *
 * This is usually overlaid on a C struct whose first element is a
 * JNINativeInterface*.  We rely somewhat on compiler behavior.
 */
struct _JNIEnv {
    /* do not rename this; it does not seem to be entirely opaque */
    const struct JNINativeInterface* functions;

#if defined(__cplusplus)

    jint GetVersion()
    { return functions->GetVersion(this); }
    
    ...
}
~~~

可知：

* C 文件中：JNIEnv 实际是 `struct JNINativeInterface*` 类型，指针变量类型；
* C++ 文件中：JNIEnv 实际是 `struct _JNIEnv` 类型，结构体变量类型。而该结构体内部则又定义了`struct JNINativeInterface*` 类型变量作为元素。**C++ 只是对 C 的那一套进行的封装，给一个变量赋值为指针（C++ 是比 C 更抽象的语言）**。
* 具体方法都是在 `struct JNINativeInterface` 中定义的。 

在使用时，比如：

~~~c
/*
* Class:     com_arthur_ndk_JniTest
* Method:    getStringFromNative
* Signature: ()Ljava/lang/String;
*/
JNIEXPORT jstring JNICALL Java_com_arthur_ndk_JniTest_getStringFromNative
(JNIEnv *jniEnv, jclass jclz) {
	// 将 C 字符串，转化为 Java 字符串
	return (*jniEnv)->NewStringUTF(jniEnv, "Hello NDK!");
	
	// cpp return jniEnv->NewStringUTF("Hello NDK!");
}
~~~

* C 文件中：jniEnv 变量实际就是 二级指针变量；
* C++ 文件中：jniEnv 变量实际是 一级指针变量，但在调用具体方法时会将 this 作为参数传递给 `struct JNINativeInterface` 中定义的方法

具体不同可从下述实例看出：

~~~c
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>

typedef struct JNINativeInterface_* JNIEnv;

struct JNINativeInterface_ {
	char* (*NewStringUTF)(JNIEnv*, char*);
};

char* getString(JNIEnv* env, char* str) {
	return str;
}

void main(int argc, char* argv) {
	printf("Hello World!\n");
	
	struct JNINativeInterface_ struct_env;
	struct_env.NewStringUTF = getString;

	JNIEnv jniEnv = &struct_env;
	JNIEnv* env = &jniEnv;

	char* str = (*env)->NewStringUTF(env, "Hello NDK!");
	printf("%s\n", str);

	system("pause");
}
~~~

此外 C++ 和 C 中使用 struct 的不同：

~~~c
#if defined(__cplusplus)
typedef _JNIEnv JNIEnv;
typedef _JavaVM JavaVM;
#else
typedef const struct JNINativeInterface* JNIEnv;
typedef const struct JNIInvokeInterface* JavaVM;
#endif
~~~

在 C++ 中，定义别名时，可以不用加 struct 标识！

> 最终的问题：为什么会有这个不同？

# 3 JNI 数据类型

Java 层定义的 native 方法，在生成头文件时的参数：

~~~java

package com.arthur.ndk;

public class JniTest {

    public native static String getStringFromNative();

    public native String getStringFromNativeOther();

    public static void main(String[] args) {
        System.out.println(getStringFromNative());

        JniTest test = new JniTest();
        System.out.println("Other：" + test.getStringFromNativeOther());
    }

    static {
        try {
            System.loadLibrary("CProjectDemo");
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

}

~~~

可以看出，上述定义了 2 个 native 方法，但其声明方式有不同：

* `public native static`
* `public native`

对应生成的头文件声明：

~~~c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include "jni.h"
/* Header for class com_arthur_ndk_JniTest */

#ifndef _Included_com_arthur_ndk_JniTest
#define _Included_com_arthur_ndk_JniTest
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_arthur_ndk_JniTest
 * Method:    getStringFromNative
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_arthur_ndk_JniTest_getStringFromNative
  (JNIEnv *, jclass);

/*
* Class:     com_arthur_ndk_JniTest
* Method:    getStringFromNativeOther
* Signature: ()Ljava/lang/String;
*/
JNIEXPORT jstring JNICALL Java_com_arthur_ndk_JniTest_getStringFromNativeOther
(JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif

~~~

结论：

* 每个 native 函数，都至少有两个参数：`(JNIEnv *, jclass)` 或者是 `(JNIEnv *, jobject)`；
* 当 native 方法声明为静态时，对应的 native 函数参数为 jclass，代表 Java 层 class 对象；
* 当 native 方法声明为非静态时，对应的 native 函数参数为 jobject，代表 Java 层 该方法所属的对象；

Java层 数据类型 映射到 JNI 接口，以及 JNI 接口 和 C 语言的数据类型对应关系：

~~~
Java 类型 --> JNI 类型 --> C 类型
~~~

JNI 数据类型分为：**基本数据类型** 和 **引用数据类型**、基本数据类型数组、引用数据类型。

# 4 Native 访问 Java 实例的属性

相当于需要实现『双向通信』。

~~~c
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "com_arthur_ndk_JniTest.h"

/*
* Class:     com_arthur_ndk_JniTest
* Method:    getStringFromNative
* Signature: ()Ljava/lang/String;
*/
JNIEXPORT jstring JNICALL Java_com_arthur_ndk_JniTest_getStringFromNative
(JNIEnv *jniEnv, jclass jclz) {
	// 将 C 字符串，转化为 Java 字符串
	return (*jniEnv)->NewStringUTF(jniEnv, "Hello NDK!");
}

/*
* Class:     com_arthur_ndk_JniTest
* Method:    getStringFromNativeOther
* Signature: ()Ljava/lang/String;
*/
JNIEXPORT jstring JNICALL Java_com_arthur_ndk_JniTest_getStringFromNativeOther
(JNIEnv *jniEnv, jobject jobj) {
	return (*jniEnv)->NewStringUTF(jniEnv, "Hello NDK_Other!");
}

/*
* Class:     com_arthur_ndk_JniTest
* Method:    accessField
* Signature: ()Ljava/lang/String;
*/
JNIEXPORT jstring JNICALL Java_com_arthur_ndk_JniTest_accessField
(JNIEnv *jniEnv, jobject jobj) {
	// 目标：获取到 jobj 对象的属性，并修改后返回

	// FindClass 和 GetOjbectClass 的区别？
	jclass clazz = (*jniEnv)->GetObjectClass(jniEnv, jobj);

	const char* fieldName = "objectField";
	const char* sig = "Ljava/lang/String;";

	jfieldID fieldID = (*jniEnv)->GetFieldID(jniEnv, clazz, fieldName, sig);

	jstring field = (*jniEnv)->GetObjectField(jniEnv, jobj, fieldID);

	// 在 Eclipse 中创建 Java 工程时，可直接在控制台打印；如果是 Android 工程，只需要借助 Log
	// jstring --> char[] 或 char*  此处参数不能为 JNIN_TRUE
	const jbyte* value = (*jniEnv)->GetStringUTFChars(jniEnv, field, JNI_FALSE);
	printf("Native field content is: %s", value);

	char tmp[20] = "changed: ";
	strcat(tmp, value);

	// char[] 或 char* 转化为 jstring
	jstring changed = (*jniEnv)->NewStringUTF(jniEnv, tmp);

	// 重新设置 类对象的 属性值
	(*jniEnv)->SetObjectField(jniEnv, jobj, fieldID, changed);

	(*jniEnv)->ReleaseStringUTFChars(jniEnv, field, value);

	return changed;
}

void main(int argc, char* argv) {
	printf("Hello World!\n");
	system("pause");
}
~~~

Java 层代码 触发 访问 Native 方法，此时 Native 方法获取方法所属类对象的属性，修改该属性，并返回给 Java层。

除此之外，通过 JNI，Native 方法还可以访问：属性、静态属性、方法、静态方法。

![](https://github.com/ZHANGfeng-james/AndroidNDKScenery/blob/master/NDK%E8%AF%BE%E7%A8%8B/%E9%98%B6%E6%AE%B51_%E5%88%9D%E8%AF%86NDK/pics/Java%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D%E5%88%97%E8%A1%A8.png?raw=true)

快速获取方法签名：

~~~c
E:\app\com.arthur.ndk\bin>javap -s -p com.arthur.ndk.JniTest
Compiled from "JniTest.java"
public class com.arthur.ndk.JniTest {
  public java.lang.String objectField;
    descriptor: Ljava/lang/String;
  static {};
    descriptor: ()V

  public com.arthur.ndk.JniTest();
    descriptor: ()V

  public static native java.lang.String getStringFromNative();
    descriptor: ()Ljava/lang/String;

  public native java.lang.String getStringFromNativeOther();
    descriptor: ()Ljava/lang/String;

  public native java.lang.String accessField();
    descriptor: ()Ljava/lang/String;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
}

~~~

# 5 Native 访问类的构造方法

通过访问类的构造方法，就可以在 Native 中创建类的对象。比如下述就是在 Native 代码中访问 java.util.Date 的构造方法，并返回了该类的实例：

~~~c
/*
* Class:     com_arthur_ndk_JniTest
* Method:    accessConstructor
* Signature: ()J
*/
JNIEXPORT jobject JNICALL Java_com_arthur_ndk_JniTest_accessConstructor
(JNIEnv *jniEnv, jobject jobj) {
	// 在 Native 代码中，访问某个类的构造方法
	jclass cls = (*jniEnv)->FindClass(jniEnv, "java/util/Date");
	// 获取 jmethodID
	jmethodID methodID = (*jniEnv)->GetMethodID(jniEnv, cls, "<init>", "()V");
	// 实例化对象
	jobject obj = (*jniEnv)->NewObject(jniEnv, cls, methodID);
	// 获取待调用方法的 jmethodID
	jmethodID mid = (*jniEnv)->GetMethodID(jniEnv, cls, "getTime", "()J");
	jlong time = (*jniEnv)->CallLongMethod(jniEnv, obj, mid);

	printf("Get Time:%lld\n", time);

	return obj;
}
~~~

# 6 Native 调用父类方法

在 Java 层中创建了 子类对象（父类引用指向子类实例对象）。如果在 Java 层中，通过该对象只能访问子类被覆写的方法：

~~~java

package com.arthur.ndk;

import java.util.Date;

public class JniTest {

	...
    
    public Human human = new Man();
    
    public native void accessNonVirtualMethod();

	...

    public static void main(String[] args) {
		...
        test.human.sayHi();
        ...
    }

    static {
        try {
            System.loadLibrary("CProjectDemo");
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

}
~~~

但是通过 accessNonVirtualMethod() 就可以访问父类的方法。

~~~c
/*
* Class:     com_arthur_ndk_JniTest
* Method:    accessNonVirtualMethod
* Signature: ()V
*/
JNIEXPORT void JNICALL Java_com_arthur_ndk_JniTest_accessNonVirtualMethod
(JNIEnv *jniEnv, jobject jobj) {
	// 获取到调用这个方法的 实例对象
	jclass cls = (*jniEnv)->GetObjectClass(jniEnv, jobj);
	// 获取该实例对象的属性ID
	jfieldID fid = (*jniEnv)->GetFieldID(jniEnv, cls, "human", "Lcom/arthur/ndk/Human;");
	// 获取该属性对象
	jobject human_obj = (*jniEnv)->GetObjectField(jniEnv, jobj, fid);

	// 获取需要执行的方法 jclass
	jclass sayHi_class = (*jniEnv)->FindClass(jniEnv, "com/arthur/ndk/Human");
	// 获取待调用方法的methodID
	jmethodID methodID = (*jniEnv)->GetMethodID(jniEnv, sayHi_class, "sayHi", "()V");

	// 这种方法依然是子类方法
	// (*jniEnv)->CallObjectMethod(jniEnv, human_obj, methodID);

	(*jniEnv)->CallNonvirtualObjectMethod(jniEnv, human_obj, sayHi_class, methodID);
}
~~~

需要注意：

* 获取到的 `sayHi_class` 必须是父类；
* 调用方法时，需要执行：`CallNonvirtualObjectMethod()`；

# 7 字符串的乱码问题

~~~c
/*
* Class:     com_arthur_ndk_JniTest
* Method:    chineseChars
* Signature: (Ljava/lang/String;)Ljava/lang/String;
*/
JNIEXPORT jstring JNICALL Java_com_arthur_ndk_JniTest_chineseChars
(JNIEnv *jniEnv, jobject jobj, jstring jstr) {

	// const jbyte* values = (*jniEnv)->GetStringUTFChars(jniEnv, jstr, JNI_FALSE);
	// printf("parameters: %s\n", values);

	char* values = "深圳";

	jstring content = (*jniEnv)->NewStringUTF(jniEnv, values);

	return content;
}
~~~

在 Java 层中打印出 content 时，会有乱码产生。

> 原因：此处是 UTF ，但是中文编码是 GBK2312。
>
> 解决的办法：使用 Java 中强大的 API 实现转换！

~~~c
/*
* Class:     com_arthur_ndk_JniTest
* Method:    chineseChars
* Signature: (Ljava/lang/String;)Ljava/lang/String;
*/
JNIEXPORT jstring JNICALL Java_com_arthur_ndk_JniTest_chineseChars
(JNIEnv *jniEnv, jobject jobj, jstring jstr) {

	// const jbyte* values = (*jniEnv)->GetStringUTFChars(jniEnv, jstr, JNI_FALSE);
	// printf("parameters: %s\n", values);

	char values[] = "深圳和广州";
	// jstring content = (*jniEnv)->NewStringUTF(jniEnv, values);

	// 解决问题的思路：调用 Java 中的 API 实现转换
	jclass cls = (*jniEnv)->FindClass(jniEnv, "java/lang/String");
	jmethodID mid = (*jniEnv)->GetMethodID(jniEnv, cls, "<init>", "([BLjava/lang/String;)V");

	jbyteArray bytes = (*jniEnv)->NewByteArray(jniEnv, strlen(values));
	(*jniEnv)->SetByteArrayRegion(jniEnv, bytes, 0, strlen(values), values);

	jstring charsetName = (*jniEnv)->NewStringUTF(jniEnv, "GB2312");

	return (*jniEnv)->NewObject(jniEnv, cls, mid, bytes, charsetName);
}
~~~

通过调用 Java 中 java.lang.String 类的 下述方法可以实现转化：

~~~java
  public java.lang.String(byte[], java.lang.String) throws java.io.UnsupportedEncodingException;
    descriptor: ([BLjava/lang/String;)V
~~~

# 8 JNI 中数组的处理

在 Java 层中给 Native 层传入 数组，并进行排序操作：

~~~c
int sort_function(const void *a, const void *b) {
	return(strcmp(a, b));
}

/*
* Class:     com_arthur_ndk_JniTest
* Method:    giveIntArray
* Signature: ([I)V
*/
JNIEXPORT void JNICALL Java_com_arthur_ndk_JniTest_giveIntArray
(JNIEnv *jniEnv, jobject jobj, jintArray ints) {
	printf("1 function is run...\n");
	jint* values = (*jniEnv)->GetIntArrayElements(jniEnv, ints, JNI_FALSE);

	int length = (*jniEnv)->GetArrayLength(jniEnv, ints);
	qsort(values, length, sizeof(jint), sort_function);

	(*jniEnv)->ReleaseIntArrayElements(jniEnv, ints, values, 0);

	printf("2 function is run...\n");
}
~~~

需要注意的是：

* 排序操作使用的是标准 C 语言库中的方法：`qsort()`；
* 必须执行了 `ReleaseIntArrayElements()` 才会将排序结果回传到 Java 层中（相当于数据内容同步）；
* 上述方法的参数，有以下几种情况：
  1. 0 表示 Java 数组进行更新，并且释放 C/C++ 数组；
  2. JNI_ABORT Java数组不进行更新，但释放 C/C++ 数组；
  3. JNI_COMMIT Java数组进行更新，不释放 C/C++ （函数执行完，数组还是会释放）。

# 9 JNI 引用变量

JNI 中引用变量有 2 种：**局部引用** 和 **全局引用**。

引用变量的作用：在 JNI 中告知虚拟机何时回收一个 JNI 变量。

局部引用，通过`DeleteLocalRef()`手动释放对象，有以下情况：

1. 访问一个很大的 Java 对象，使用完之后，还要进行复杂的耗时操作；
2. 创建了大量的局部引用，占用了太多的内存，而且这些局部引用跟后面的操作没有关联性。

全局引用的特点：

1. 实现变量共享，可以跨多个线程；
2. 手动控制内存使用。

弱全局引用的特点：

1. 节省内存，在内存不足时可以释放所引用的对象；
2. 可以引用一个不常用的对象，如果是NULL ，临时再去创建；

# 10 异常处理

在 Native 方法中发生了异常时，Java层调用该 native 方法的地方，后续代码不会被执行，可以被 Throwable catch 到。

Native 层的异常处理，可以保证 Java 代码可以正常运行；补救措施保证 Native 代码继续运行。

~~~c
/*
* Class:     com_arthur_ndk_JniTest
* Method:    exception
* Signature: ()V
*/
JNIEXPORT void JNICALL Java_com_arthur_ndk_JniTest_exception
(JNIEnv *jniEnv, jobject jobj) {
	jclass cls = (*jniEnv)->GetObjectClass(jniEnv, jobj);
	jfieldID fid = (*jniEnv)->GetFieldID(jniEnv, cls, "objectField2", "Ljava/lang/String;");

	jthrowable exception = (*jniEnv)->ExceptionOccurred(jniEnv);
	if (exception != NULL) {
		// 让 java 代码可以继续运行，需要清空异常信息
		(*jniEnv)->ExceptionClear(jniEnv);

		fid = (*jniEnv)->GetFieldID(jniEnv, cls, "objectField", "Ljava/lang/String;");
	}

	// 获取属性的值
	jstring jstr = (*jniEnv)->GetObjectField(jniEnv, jobj, fid);
	// jstring --> char*
	char* str = (*jniEnv)->GetStringUTFChars(jniEnv, jstr, NULL);
	// 对比属性值是否合法
	if (_stricmp(str, "changed: XXXX") != 0) {
		// 认为抛出异常，给Java层处理
		jclass newExcCls = (*jniEnv)->FindClass(jniEnv, "java/lang/IllegalArgumentException");
		(*jniEnv)->ThrowNew(jniEnv, newExcCls, "key's value is invalid!");
	}
}
~~~

JNI 自己抛出的异常，在 Java 层无法被捕捉，只能在 Native 层清空；用户通过 ThrowNew 抛出的异常，可以在 Java 层捕捉。

# 11 JNI 缓存策略

**局部静态变量的缓存策略**：

~~~c
/*
* Class:     com_arthur_ndk_JniTest
* Method:    cached
* Signature: (I)V
*/
JNIEXPORT void JNICALL Java_com_arthur_ndk_JniTest_cached
(JNIEnv *jniEnv, jobject jobj, jint values) {
	jclass cls = (*jniEnv)->GetObjectClass(jniEnv, jobj);

	static jfieldID fid = NULL;
	if (fid == NULL) {
		fid = (*jniEnv)->GetFieldID(jniEnv, cls, "objectField", "Ljava/lang/String;");
		printf("function is execute: %d\n", values);
	}
}
~~~

此时，定义了局部静态变量`fid`，虽然是局部变量，但是其生命周期会是整个程序运行时期，但是声明周期只是本函数内部。也就是说：一旦执行了复制操作，该方法反复执行多次，将不会再次被赋值。

初始化全局变量的缓存策略：

~~~c
// 初始化全局变量
jfieldID fieldId;
jmethodID methodId;

/*
* Class:     com_arthur_ndk_JniTest
* Method:    initNative
* Signature: ()V
*/
JNIEXPORT void JNICALL Java_com_arthur_ndk_JniTest_initNative
(JNIEnv *jniEnv, jclass cls) {
	fieldId = (*jniEnv)->GetFieldID(jniEnv, cls, "objectField", "Ljava/lang/String;");
	methodId = (*jniEnv)->GetMethodID(jniEnv, cls, "giveIntArray", "([I)V");
}
~~~

一般是在动态库加载完成后，立即初始化并缓存起来：

~~~java
static {
	try {
		System.loadLibrary("CProjectDemo");
		initNative();
	} catch (Exception e) {
		System.out.println(e.getMessage());
	}
}
~~~
# 12 大型应用的跨平台解决方案

比如绝大多数即时通讯的 App，都会使用 C/C++ 实现底层通讯的库。原因：

1. 保持iPhone、Android、Windows Phone等执行平台一致性（跨平台），不需要重新开发；
2. 快速，增加反编译的难度。

# 13 增量更新

> 静默安装需要 root 权限；
>
> **插件式开发**（往宿主程序里面安装插件，一个插件相当于是新增一个功能；如果宿主程序需要更新，只能采用其他方式）、**热修复**，都可以实现 App 的更新。
>
> **增量更新**主要是用于解决：宿主程序需要更新的场景。

增量更新步骤：

1. 在服务器上，根据 App 的不同版本**生成不同的 .patch 差分包文件**（可以节省用户流量）；

   > 一旦在服务器端上传了新版本的 Apk，服务器端立即会生成差分包。

2. App 客户端根据当前版本**下载** .patch 差分包文件；

3. App 客户端**合成**新版本 App 安装文件；

4. 执行 App **安装**。

> 难点：不同市场渠道，不同版本 App 增量更新时，需要的差分包文件。服务器难度会比客户端大！

## 13.1 服务器端

binary diff / patch utility 同时引用了 bzip，其中前者用于做差分，后者用于做合并。

> 上述开源项目，不仅有 Windows 环境下的编译的源代码，也有 Linux 下的源代码。

开发的环境如果是 Windows，部署环境是 Linux，需要上述开源项目的源代码，以此生成 .dll 和 .so 动态库。

步骤：

1. 在 Visual Studio 中新建项目，编译 bsDiff 源代码，生成 .dll 动态库，用于得到差分包文件；
   * 问题1：使用了不安全的函数；解决办法：工程属性 --> C/C++ 命令行，增加 `-D _CRT_SECURE_NO_WARNINGS`；
   * 问题2：使用了过时的函数；解决办法：在上述同样地方增加 `-D _CRT_NONSTDC_NO_DEPRECATE`；
   * 问题3：变量未作初始化工作（可能的原因是使用MAC电脑开发，编译器不做严格的语法检查）；解决办法：工程属性 --> C/C++ 常规，设置 SDL 检查为否。
2. 修改 bsdiff.cpp 源文件；
3. 根据上述代码，编写 Java 层 native 代码，生成头文件；
4. 编写 JNI 函数，供 Java层调用；

> Mac OS 或者是 Linux 系统的默认编码格式为：UTF-8 无 BOM 格式编码。注意统一编码！