
最近数据泄露似乎出现的比较频繁，这半年以来已经有华住，陌陌，Quora，12306 .....出现数据泄露。当然，现在大多数网站存储的密码也不再会是明文形式了。今天，我们借密码泄露事件谈一谈怎样才能安全地保存用户密码这么重要的数据呢？

首先，要知道如何保存用户密码，我们必须先要明白哈希算法。
什么是哈希算法：
我们知道散列表，散列函数吧？不知道没关系，我下文会介绍，可以暂时做个简单了解。

哈希算法的定义就是将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。

一个好的哈希算法需要满足以下几个条件：
- 从哈希值不能反向推导出原始数据
- 对输入数据敏感，那怕原始数据只修改了一个bit，最后得到的哈希值也大不相同。
- 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小
- 哈希算法的执行效率要尽量高，针对较长的文本，也能快速地计算出哈希值。
  
业界著名的哈希算法有诸如 MD5,SHA，DES, AES 等优秀的算法。但仍然不能算作很完美。
先来看看MD5算法吧
## MD5 加密实例
先看一种 md5 加密的实现代码：
```
 
    public static String md5(String plainText) {
        //定义一个字节数组
        byte[] secretBytes = null;
        try {
            // 生成一个MD5加密计算摘要
            MessageDigest md = MessageDigest.getInstance("MD5");
            //对字符串进行加密
            md.update(plainText.getBytes());
            //获得加密后的数据
            secretBytes = md.digest();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("没有md5这个算法！");
        }
        //将加密后的数据转换为16进制数字
        String md5code = new BigInteger(1, secretBytes).toString(16);// 16进制数字
        // 如果生成数字未满32位，需要前面补0
        for (int i = 0; i < 32 - md5code.length(); i++) {
            md5code = "0" + md5code;
        }
        return md5code;
    }
```
通过以上 MD5 算法加密后，我们发现加密后的密文有两个很突出的特点：
1. 无论要哈希的文本有多长或者多短，通过哈希后的值的长度都是相同的。
   ```
    md5("asdfaf545413adafakfljsfa")  7404686fc7bff68dc560021f9bc08329
    md5("好")                        ac2c8f13c6e60810197b19d683f5f184
   ```
2. 改变一个字符就会有很大的差别
    ```
     md5("asdfaf545413adafakfljsfa")  7404686fc7bff68dc560021f9bc08329
     md5("asdfaf645413adafakfljsfa")  9fc80292ab77a83f8d68e5eb708a73b3                
    ```
    我只将其中一个数字 5 变成了数字 6 ，但是密文变化特别大。


### 字典攻击
但是通过这段实例，我们也发现了虽然哈希算法是不可逆的，但如果数据被脱裤，虽然拿到的是加密后的密文，但可以通过猜的方式来破解密码，这是因为，有些用户的密码太简单。比如很多人习惯用
000000 123456 这样的简单数字组合做密码，就很容易被猜中。 关于字典攻击，这里有一篇关于彩虹表的文章可以帮助我们理解字典攻击[什么是彩虹表](https://www.zhihu.com/question/19790488)

针对字典攻击，我们引入一个salt，跟用户的密码组合在一起，增加密码的复杂度，同时即使破解之后也无法拿到所有用户的数据。我们拿组合之后的字符串来说，
将它存储到数据库中，进一步增加破解的难度。不过我这里想多说一句，我认为安全和攻击是一种博弈关系，不存在绝对的安全。所有的安全措施，就是增加攻击的成本而已。

基于哈希算法的 4 个特点，我们有很多应用，例如：
### 应用：安全加密
最常用于安全加密的哈希算法是：MD5,SHA,除此之外还有很多加密算法，如DES,AES
对于加密算法有两点非常重要
- 1.很难根据哈希值反向推导出原始数据，
- 2.散列冲突的概率要很小。
  
第一点就是要保证加密后原始数据的泄露而导致数据被反向推导出来。不管什么哈希算法，都无法做到绝对的 0 冲突，我们只能做到减少冲突。

在组合数学中有这样一个理论，鸽笼原理，如果有 10 个鸽笼，但是有 11 只鸽子，必然会有至少有两只鸽子在一个鸽笼里。

我们知道，哈希算法产生的哈希值的长度是固定且有限的。比如前面举的 MD5 的例子，哈希值是固定的 128 位二进制串，能表示的数据非常有限，最多只能表示 2^128 个数据，但是现实情况是数据非常多。

不过，即便哈希算法存在散列冲突的情况，但是因为哈希值的范围很大，冲突的概率极低，所以相对来说还是很难破解。如 MD5 2^128 这已经是一个天文数字了。
如果拿到一个MD5哈希值，希望通过穷举的方法来找出答案，那耗费的时间也是一个天文数字。
在平时开发中，我们也需要权衡选择算法的利弊，虽然有更高的加密算法，但是时间效率也会降低。所以，我们在实际开发中也需要不同的需求选择不同的哈希算法。


### 应用：唯一标识
如果要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息来比对，因为有可能存在名称相同但图片内容不同，或者名称不同图片相同的情况。那又该如何搜索呢？

任何文件在计算机中都可以表示成二进制码串，所以，比较笨的办法就是，拿要查找的图片的二进制码串与图库中所有图片的二进制码串进行比对。如果相同，则说明图片存在，但是这种比对方法太耗时了。

所以，我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取100个字节，从最后再取100个字节，然后将这300个字节放在一块，通过哈希算法得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样可以减少很多工作量。

如果不存在，那就说明这个图片不在图库中，如果存在，我们再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在，如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。

### 应用：数据校验
目前很多软件都是基于 p2p 协议下载，就是我们可以从多个机器并行下载一个文件，这个文件可能被分割成很多文件块。等所有文件块都下载
完成后，在组装成一个完整的电影文件。但是我们知道，网络传输是不安全的，下载的文件块很有可能被宿主机器恶意修改过，又或者下载过程汇总出现了错误，所以下载的文件块很有可能是不完整的。如果我们没有能力检测这种恶意修改或者文件下载出错，就会导致最终合并后的电影无法观看，甚至导致电脑中毒。现在的问题是怎样校验。

我们通过哈希算法，对100个文件块分别取哈希值，并且保存在种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点的改变，最后计算出的哈希值就会完全不同。所以，当文件下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的
哈希值进行比对。如果不同，则说明被篡改了。

